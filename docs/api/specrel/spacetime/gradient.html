<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>specrel.spacetime.gradient API documentation</title>
<meta name="description" content="Objects that form color gradients across regions of spacetime, representing
continuous change of some sort." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>specrel.spacetime.gradient</code></h1>
</header>
<section id="section-intro">
<p>Objects that form color gradients across regions of spacetime, representing
continuous change of some sort.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;Objects that form color gradients across regions of spacetime, representing
continuous change of some sort.
&#34;&#34;&#34;

from matplotlib.colors import to_rgba

import specrel.geom as geom

def _calc_colorgrad(x, point1, point2, color1, color2):
    &#34;&#34;&#34;Calculate a linear color gradient value between two points at some
    proportion x, where 0 is the start point/color, and 1 is the end
    point/color.
    &#34;&#34;&#34;
    color1 = to_rgba(color1)
    color2 = to_rgba(color2)
    xpoint = tuple([p1 + x*(p2 - p1) for p1, p2 in zip(point1, point2)])
    xcolor = tuple([c1 + x*(c2 - c1) for c1, c2 in zip(color1, color2)])
    return xpoint, xcolor

def _valid_color(col):
    &#34;&#34;&#34;Checks whether an rgba value is a valid color or not.&#34;&#34;&#34;
    for c in col:
        if c &lt; 0 or c &gt; 1:
            return False
    return True

def _colorgrad_extremes(point1, point2, color1, color2, divisions):
    &#34;&#34;&#34;Extrapolates a linear color gradient between two points to the extreme
    endpoints of colorspace, at some interval resolution.
    &#34;&#34;&#34;
    # Extend the range backwards
    i1 = 0
    while _valid_color(_calc_colorgrad(
        -(i1+1)/divisions, point1, point2, color1, color2)[1]):
        i1 += 1
    # Extend the range forwards
    i2 = 0
    while _valid_color(_calc_colorgrad(
        1 + (i2+1)/divisions, point1, point2, color1, color2)[1]):
        i2 += 1

    # Get the final extremes of the range
    ext_point1, ext_color1 = _calc_colorgrad(-i1/divisions,
        point1, point2, color1, color2)
    ext_point2, ext_color2 = _calc_colorgrad(1 + i2/divisions,
        point1, point2, color1, color2)
    return ext_point1, ext_point2, ext_color1, ext_color2, divisions + i1 + i2

def gradient_line(point1, point2, color1, color2, divisions=100,
    extrapolate_color=True, draw_options=geom.geomrc[&#39;draw_options&#39;]):
    &#34;&#34;&#34;A line with a color gradient. The gradient transition will happen over
    a finite range in spacetime, and be monochromatic at either end.

    Args:
        point1 (specrel.geom.STVector or iterable): Starting point of the
            gradient.
        point2 (specrel.geom.STVector or iterable): Ending point of the
            gradient.
        color1 (color): A Matplotlib color for the gradient starting color.
        color2 (color): A Matplotlib color for the gradient ending color.
        divisions (int, optional): The number of line segment divisions in the
            gradient. More divisions means a smoother gradient.
        extrapolate_color (bool, optional): Flag for whether or not to
            extrapolate the color gradient across the line past the specified
            endpoints so that the color change spans as far as possible across
            the line.
        draw_options (dict, optional): See `specrel.geom.LorentzTransformable`.

    Returns:
        specrel.geom.Collection:
            Collection containing the color gradient increments, in the order:

            1. `specrel.geom.Ray` before `point1` with `color1`.
            2. Line segments changing color from `point1` to `point2`.
            3. `specrel.geom.Ray` after `point2` with `color2`.
    &#34;&#34;&#34;
    # Copy draw_options and remove color if it&#39;s there
    draw_options = dict(draw_options)
    draw_options.pop(&#39;color&#39;, None)

    # If extrapolating color, calculate the color gradient extremes
    if extrapolate_color:
        point1, point2, color1, color2, divisions = _colorgrad_extremes(
            point1, point2, color1, color2, divisions)

    # Color gradient calculator for the given points and colors
    def this_colorgrad(x):
        return _calc_colorgrad(x, point1, point2, color1, color2)

    # Line direction vector
    direc = geom.STVector(point2) - geom.STVector(point1)

    grad = geom.Collection()
    # Monochromatic ray at the tail end of the gradient line
    grad.append(geom.Ray(-direc, point1,
        draw_options={&#39;color&#39;: color1, **draw_options}))
    # The line segments comprising the color gradient
    for i in range(divisions):
        start_point, _ = this_colorgrad(i/divisions)
        end_point, _ = this_colorgrad((i+1)/divisions)
        _, grad_color = this_colorgrad((i+1/2)/divisions)
        grad.append(geom.line_segment(start_point, end_point,
            draw_options={&#39;color&#39;: grad_color, **draw_options}))
    # Monochromatic ray at the head end of the gradient line
    grad.append(geom.Ray(direc, point2,
        draw_options={&#39;color&#39;: color2, **draw_options}))
    return grad

def longitudinal_gradient_ribbon(line1_endpoints, line2_endpoints, color1,
    color2, divisions=100, extrapolate_color=True,
    draw_options=geom.geomrc[&#39;draw_options&#39;]):
    &#34;&#34;&#34;A `specrel.geom.Ribbon`-esque object with a longitudinal color gradient
    (across the infinite direction).

    Args:
        line1_endpoints (list): list of two `specrel.geom.STVector`-convertible
            points defining the start and end positions of the gradient along
            the first edge of the ribbon.
        line2_endpoints (list): Same as `line1_endpoints`, but for the second
            edge of the ribbon.
        color1 (color): A Matplotlib color for the gradient starting color.
        color2 (color): A Matplotlib color for the gradient ending color.
        divisions (int, optional): The number of line segment divisions in the
            gradient. More divisions means a smoother gradient.
        extrapolate_color (bool, optional): Flag for whether or not to
            extrapolate the color gradient across the ribbon past the specified
            endpoints so that the color change spans as far as possible across
            the ribbon.
        draw_options (TYPE, optional): See `specrel.geom.LorentzTransformable`.

    Returns:
        specrel.geom.Collection:
            Collection containing the color gradient increments, in the order:

            1. `specrel.geom.HalfRibbon` with `color1` before both line starting
                points.
            2. Polygons changing color from starts of the lines to the ends.
            3. `specrel.geom.HalfRibbon` with `color2` after both line ending
                points.
    &#34;&#34;&#34;
    # Copy draw_options and remove color, facecolor, and edgecolor if they&#39;re
    # there
    draw_options = dict(draw_options)
    draw_options.pop(&#39;color&#39;, None)
    draw_options.pop(&#39;facecolor&#39;, None)
    draw_options.pop(&#39;edgecolor&#39;, None)

    # If extrapolating color, calculate the color gradient extremes
    if extrapolate_color:
        point1, point2, color1, color2, divisions = _colorgrad_extremes(
            *line1_endpoints, color1, color2, divisions)
        line1_endpoints = (point1, point2)
        point1, point2, _, _, _ = _colorgrad_extremes(
            *line2_endpoints, color1, color2, divisions)
        line2_endpoints = (point1, point2)

    # Color gradient calculators for each line with the given colors
    def line1_colorgrad(x):
        return _calc_colorgrad(x, *line1_endpoints, color1, color2)
    def line2_colorgrad(x):
        return _calc_colorgrad(x, *line2_endpoints, color1, color2)

    # Direction vectors of each line
    direc1 = geom.STVector(line1_endpoints[1]) - geom.STVector(line1_endpoints[0])
    direc2 = geom.STVector(line2_endpoints[1]) - geom.STVector(line2_endpoints[0])
    grad = geom.Collection()
    # Form the monochromatic half ribbon at the tail end of the gradient
    # Overlap with the first polygon by half a division to mitigate any
    # boundary gaps
    start_point1, _ = line1_colorgrad(1/(2*divisions))
    start_point2, _ = line2_colorgrad(1/(2*divisions))
    grad.append(geom.HalfRibbon(
        geom.Ray(-direc1, start_point1),
        geom.Ray(-direc2, start_point2),
        # Explicitly turn off edge coloring
        draw_options={&#39;facecolor&#39;: color1, &#39;edgecolor&#39;: &#39;None&#39;, **draw_options}))
    # Interior polygons comprising the color gradient
    for i in range(divisions):
        start_point1, _ = line1_colorgrad(i/divisions)
        # Overlap bands by half a division
        end_point1, _ = line1_colorgrad((i+1+1/2)/divisions)
        start_point2, _ = line2_colorgrad(i/divisions)
        end_point2, _ = line2_colorgrad((i+1+1/2)/divisions)
        _, grad_color = line1_colorgrad((i+1/2)/divisions)
        grad.append(geom.polygon(
            [start_point1, end_point1, end_point2, start_point2],
            draw_options={&#39;facecolor&#39;: grad_color, **draw_options}))
    # Monochromatic half ribon at the head end of the gradient
    grad.append(geom.HalfRibbon(
        geom.Ray(direc1, line1_endpoints[1]),
        geom.Ray(direc2, line2_endpoints[1]),
        draw_options={&#39;facecolor&#39;: color2, &#39;edgecolor&#39;: &#39;None&#39;, **draw_options}))
    return grad

def lateral_gradient_ribbon(direction, point1, point2, color1, color2,
    divisions=100, draw_options=geom.geomrc[&#39;draw_options&#39;]):
    &#34;&#34;&#34;A `specrel.geom.Ribbon`-esque object with a lateral color gradient
    (across the finite direction).

    Args:
        direction (specrel.geom.STVector or iterable): Direction vector for the
            gradient.
        point1 (specrel.geom.STVector or iterable): A point that the first edge
            of the ribbon passes through.
        point2 (specrel.geom.STVector or iterable): A point that the second edge
            of the ribbon passes through.
        color1 (color): A Matplotlib color for the gradient starting color.
        color2 (color): A Matplotlib color for the gradient ending color.
        divisions (int, optional): The number of line segment divisions in the
            gradient. More divisions means a smoother gradient.
        draw_options (TYPE, optional): See `specrel.geom.LorentzTransformable`.

    Returns:
        specrel.geom.Collection:
            Collection containing the `specrel.geom.Ribbon` objects of slowly
            changing color from `point1` to `point2`.
    &#34;&#34;&#34;
    # Copy draw_options and remove color, facecolor, and edgecolor if they&#39;re
    # there
    draw_options = dict(draw_options)
    draw_options.pop(&#39;color&#39;, None)
    draw_options.pop(&#39;facecolor&#39;, None)
    draw_options.pop(&#39;edgecolor&#39;, None)

    # Color gradient calculator for the given points and colors
    def this_colorgrad(x):
        return _calc_colorgrad(x, point1, point2, color1, color2)

    grad = geom.Collection()
    # Ribbons comprising the color gradient, as we move from point1 to point2
    for i in range(divisions):
        start_point, _ = this_colorgrad(i/divisions)
        # Overlap bands by half a division, except the last one
        end_point, _ = this_colorgrad(min((i+1+1/2)/divisions, 1))
        _, grad_color = this_colorgrad((i+1/2)/divisions)
        # Explicitly turn off edge coloring
        grad.append(geom.Ribbon(
            geom.Line(direction, start_point),
            geom.Line(direction, end_point),
            draw_options={&#39;facecolor&#39;: grad_color, &#39;edgecolor&#39;: &#39;None&#39;,
                **draw_options}
        ))
    return grad</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="specrel.spacetime.gradient.gradient_line"><code class="name flex">
<span>def <span class="ident">gradient_line</span></span>(<span>point1, point2, color1, color2, divisions=100, extrapolate_color=True, draw_options={})</span>
</code></dt>
<dd>
<section class="desc"><p>A line with a color gradient. The gradient transition will happen over
a finite range in spacetime, and be monochromatic at either end.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point1</code></strong> :&ensp;<a title="specrel.geom.STVector" href="../geom.html#specrel.geom.STVector"><code>STVector</code></a> or <code>iterable</code></dt>
<dd>Starting point of the
gradient.</dd>
<dt><strong><code>point2</code></strong> :&ensp;<a title="specrel.geom.STVector" href="../geom.html#specrel.geom.STVector"><code>STVector</code></a> or <code>iterable</code></dt>
<dd>Ending point of the
gradient.</dd>
<dt><strong><code>color1</code></strong> :&ensp;<code>color</code></dt>
<dd>A Matplotlib color for the gradient starting color.</dd>
<dt><strong><code>color2</code></strong> :&ensp;<code>color</code></dt>
<dd>A Matplotlib color for the gradient ending color.</dd>
<dt><strong><code>divisions</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of line segment divisions in the
gradient. More divisions means a smoother gradient.</dd>
<dt><strong><code>extrapolate_color</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag for whether or not to
extrapolate the color gradient across the line past the specified
endpoints so that the color change spans as far as possible across
the line.</dd>
<dt><strong><code>draw_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>See <a title="specrel.geom.LorentzTransformable" href="../geom.html#specrel.geom.LorentzTransformable"><code>LorentzTransformable</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="specrel.geom.Collection" href="../geom.html#specrel.geom.Collection"><code>Collection</code></a>:</dt>
<dd>
<p>Collection containing the color gradient increments, in the order:</p>
<ol>
<li><a title="specrel.geom.Ray" href="../geom.html#specrel.geom.Ray"><code>Ray</code></a> before <code>point1</code> with <code>color1</code>.</li>
<li>Line segments changing color from <code>point1</code> to <code>point2</code>.</li>
<li><a title="specrel.geom.Ray" href="../geom.html#specrel.geom.Ray"><code>Ray</code></a> after <code>point2</code> with <code>color2</code>.</li>
</ol>
</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gradient_line(point1, point2, color1, color2, divisions=100,
    extrapolate_color=True, draw_options=geom.geomrc[&#39;draw_options&#39;]):
    &#34;&#34;&#34;A line with a color gradient. The gradient transition will happen over
    a finite range in spacetime, and be monochromatic at either end.

    Args:
        point1 (specrel.geom.STVector or iterable): Starting point of the
            gradient.
        point2 (specrel.geom.STVector or iterable): Ending point of the
            gradient.
        color1 (color): A Matplotlib color for the gradient starting color.
        color2 (color): A Matplotlib color for the gradient ending color.
        divisions (int, optional): The number of line segment divisions in the
            gradient. More divisions means a smoother gradient.
        extrapolate_color (bool, optional): Flag for whether or not to
            extrapolate the color gradient across the line past the specified
            endpoints so that the color change spans as far as possible across
            the line.
        draw_options (dict, optional): See `specrel.geom.LorentzTransformable`.

    Returns:
        specrel.geom.Collection:
            Collection containing the color gradient increments, in the order:

            1. `specrel.geom.Ray` before `point1` with `color1`.
            2. Line segments changing color from `point1` to `point2`.
            3. `specrel.geom.Ray` after `point2` with `color2`.
    &#34;&#34;&#34;
    # Copy draw_options and remove color if it&#39;s there
    draw_options = dict(draw_options)
    draw_options.pop(&#39;color&#39;, None)

    # If extrapolating color, calculate the color gradient extremes
    if extrapolate_color:
        point1, point2, color1, color2, divisions = _colorgrad_extremes(
            point1, point2, color1, color2, divisions)

    # Color gradient calculator for the given points and colors
    def this_colorgrad(x):
        return _calc_colorgrad(x, point1, point2, color1, color2)

    # Line direction vector
    direc = geom.STVector(point2) - geom.STVector(point1)

    grad = geom.Collection()
    # Monochromatic ray at the tail end of the gradient line
    grad.append(geom.Ray(-direc, point1,
        draw_options={&#39;color&#39;: color1, **draw_options}))
    # The line segments comprising the color gradient
    for i in range(divisions):
        start_point, _ = this_colorgrad(i/divisions)
        end_point, _ = this_colorgrad((i+1)/divisions)
        _, grad_color = this_colorgrad((i+1/2)/divisions)
        grad.append(geom.line_segment(start_point, end_point,
            draw_options={&#39;color&#39;: grad_color, **draw_options}))
    # Monochromatic ray at the head end of the gradient line
    grad.append(geom.Ray(direc, point2,
        draw_options={&#39;color&#39;: color2, **draw_options}))
    return grad</code></pre>
</details>
</dd>
<dt id="specrel.spacetime.gradient.lateral_gradient_ribbon"><code class="name flex">
<span>def <span class="ident">lateral_gradient_ribbon</span></span>(<span>direction, point1, point2, color1, color2, divisions=100, draw_options={})</span>
</code></dt>
<dd>
<section class="desc"><p>A <a title="specrel.geom.Ribbon" href="../geom.html#specrel.geom.Ribbon"><code>Ribbon</code></a>-esque object with a lateral color gradient
(across the finite direction).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>direction</code></strong> :&ensp;<a title="specrel.geom.STVector" href="../geom.html#specrel.geom.STVector"><code>STVector</code></a> or <code>iterable</code></dt>
<dd>Direction vector for the
gradient.</dd>
<dt><strong><code>point1</code></strong> :&ensp;<a title="specrel.geom.STVector" href="../geom.html#specrel.geom.STVector"><code>STVector</code></a> or <code>iterable</code></dt>
<dd>A point that the first edge
of the ribbon passes through.</dd>
<dt><strong><code>point2</code></strong> :&ensp;<a title="specrel.geom.STVector" href="../geom.html#specrel.geom.STVector"><code>STVector</code></a> or <code>iterable</code></dt>
<dd>A point that the second edge
of the ribbon passes through.</dd>
<dt><strong><code>color1</code></strong> :&ensp;<code>color</code></dt>
<dd>A Matplotlib color for the gradient starting color.</dd>
<dt><strong><code>color2</code></strong> :&ensp;<code>color</code></dt>
<dd>A Matplotlib color for the gradient ending color.</dd>
<dt><strong><code>divisions</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of line segment divisions in the
gradient. More divisions means a smoother gradient.</dd>
<dt><strong><code>draw_options</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>See <a title="specrel.geom.LorentzTransformable" href="../geom.html#specrel.geom.LorentzTransformable"><code>LorentzTransformable</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="specrel.geom.Collection" href="../geom.html#specrel.geom.Collection"><code>Collection</code></a>:</dt>
<dd>Collection containing the <a title="specrel.geom.Ribbon" href="../geom.html#specrel.geom.Ribbon"><code>Ribbon</code></a> objects of slowly
changing color from <code>point1</code> to <code>point2</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def lateral_gradient_ribbon(direction, point1, point2, color1, color2,
    divisions=100, draw_options=geom.geomrc[&#39;draw_options&#39;]):
    &#34;&#34;&#34;A `specrel.geom.Ribbon`-esque object with a lateral color gradient
    (across the finite direction).

    Args:
        direction (specrel.geom.STVector or iterable): Direction vector for the
            gradient.
        point1 (specrel.geom.STVector or iterable): A point that the first edge
            of the ribbon passes through.
        point2 (specrel.geom.STVector or iterable): A point that the second edge
            of the ribbon passes through.
        color1 (color): A Matplotlib color for the gradient starting color.
        color2 (color): A Matplotlib color for the gradient ending color.
        divisions (int, optional): The number of line segment divisions in the
            gradient. More divisions means a smoother gradient.
        draw_options (TYPE, optional): See `specrel.geom.LorentzTransformable`.

    Returns:
        specrel.geom.Collection:
            Collection containing the `specrel.geom.Ribbon` objects of slowly
            changing color from `point1` to `point2`.
    &#34;&#34;&#34;
    # Copy draw_options and remove color, facecolor, and edgecolor if they&#39;re
    # there
    draw_options = dict(draw_options)
    draw_options.pop(&#39;color&#39;, None)
    draw_options.pop(&#39;facecolor&#39;, None)
    draw_options.pop(&#39;edgecolor&#39;, None)

    # Color gradient calculator for the given points and colors
    def this_colorgrad(x):
        return _calc_colorgrad(x, point1, point2, color1, color2)

    grad = geom.Collection()
    # Ribbons comprising the color gradient, as we move from point1 to point2
    for i in range(divisions):
        start_point, _ = this_colorgrad(i/divisions)
        # Overlap bands by half a division, except the last one
        end_point, _ = this_colorgrad(min((i+1+1/2)/divisions, 1))
        _, grad_color = this_colorgrad((i+1/2)/divisions)
        # Explicitly turn off edge coloring
        grad.append(geom.Ribbon(
            geom.Line(direction, start_point),
            geom.Line(direction, end_point),
            draw_options={&#39;facecolor&#39;: grad_color, &#39;edgecolor&#39;: &#39;None&#39;,
                **draw_options}
        ))
    return grad</code></pre>
</details>
</dd>
<dt id="specrel.spacetime.gradient.longitudinal_gradient_ribbon"><code class="name flex">
<span>def <span class="ident">longitudinal_gradient_ribbon</span></span>(<span>line1_endpoints, line2_endpoints, color1, color2, divisions=100, extrapolate_color=True, draw_options={})</span>
</code></dt>
<dd>
<section class="desc"><p>A <a title="specrel.geom.Ribbon" href="../geom.html#specrel.geom.Ribbon"><code>Ribbon</code></a>-esque object with a longitudinal color gradient
(across the infinite direction).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>line1_endpoints</code></strong> :&ensp;<code>list</code></dt>
<dd>list of two <a title="specrel.geom.STVector" href="../geom.html#specrel.geom.STVector"><code>STVector</code></a>-convertible
points defining the start and end positions of the gradient along
the first edge of the ribbon.</dd>
<dt><strong><code>line2_endpoints</code></strong> :&ensp;<code>list</code></dt>
<dd>Same as <code>line1_endpoints</code>, but for the second
edge of the ribbon.</dd>
<dt><strong><code>color1</code></strong> :&ensp;<code>color</code></dt>
<dd>A Matplotlib color for the gradient starting color.</dd>
<dt><strong><code>color2</code></strong> :&ensp;<code>color</code></dt>
<dd>A Matplotlib color for the gradient ending color.</dd>
<dt><strong><code>divisions</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of line segment divisions in the
gradient. More divisions means a smoother gradient.</dd>
<dt><strong><code>extrapolate_color</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag for whether or not to
extrapolate the color gradient across the ribbon past the specified
endpoints so that the color change spans as far as possible across
the ribbon.</dd>
<dt><strong><code>draw_options</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>See <a title="specrel.geom.LorentzTransformable" href="../geom.html#specrel.geom.LorentzTransformable"><code>LorentzTransformable</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="specrel.geom.Collection" href="../geom.html#specrel.geom.Collection"><code>Collection</code></a>:</dt>
<dd>
<p>Collection containing the color gradient increments, in the order:</p>
<ol>
<li><a title="specrel.geom.HalfRibbon" href="../geom.html#specrel.geom.HalfRibbon"><code>HalfRibbon</code></a> with <code>color1</code> before both line starting
points.</li>
<li>Polygons changing color from starts of the lines to the ends.</li>
<li><a title="specrel.geom.HalfRibbon" href="../geom.html#specrel.geom.HalfRibbon"><code>HalfRibbon</code></a> with <code>color2</code> after both line ending
points.</li>
</ol>
</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def longitudinal_gradient_ribbon(line1_endpoints, line2_endpoints, color1,
    color2, divisions=100, extrapolate_color=True,
    draw_options=geom.geomrc[&#39;draw_options&#39;]):
    &#34;&#34;&#34;A `specrel.geom.Ribbon`-esque object with a longitudinal color gradient
    (across the infinite direction).

    Args:
        line1_endpoints (list): list of two `specrel.geom.STVector`-convertible
            points defining the start and end positions of the gradient along
            the first edge of the ribbon.
        line2_endpoints (list): Same as `line1_endpoints`, but for the second
            edge of the ribbon.
        color1 (color): A Matplotlib color for the gradient starting color.
        color2 (color): A Matplotlib color for the gradient ending color.
        divisions (int, optional): The number of line segment divisions in the
            gradient. More divisions means a smoother gradient.
        extrapolate_color (bool, optional): Flag for whether or not to
            extrapolate the color gradient across the ribbon past the specified
            endpoints so that the color change spans as far as possible across
            the ribbon.
        draw_options (TYPE, optional): See `specrel.geom.LorentzTransformable`.

    Returns:
        specrel.geom.Collection:
            Collection containing the color gradient increments, in the order:

            1. `specrel.geom.HalfRibbon` with `color1` before both line starting
                points.
            2. Polygons changing color from starts of the lines to the ends.
            3. `specrel.geom.HalfRibbon` with `color2` after both line ending
                points.
    &#34;&#34;&#34;
    # Copy draw_options and remove color, facecolor, and edgecolor if they&#39;re
    # there
    draw_options = dict(draw_options)
    draw_options.pop(&#39;color&#39;, None)
    draw_options.pop(&#39;facecolor&#39;, None)
    draw_options.pop(&#39;edgecolor&#39;, None)

    # If extrapolating color, calculate the color gradient extremes
    if extrapolate_color:
        point1, point2, color1, color2, divisions = _colorgrad_extremes(
            *line1_endpoints, color1, color2, divisions)
        line1_endpoints = (point1, point2)
        point1, point2, _, _, _ = _colorgrad_extremes(
            *line2_endpoints, color1, color2, divisions)
        line2_endpoints = (point1, point2)

    # Color gradient calculators for each line with the given colors
    def line1_colorgrad(x):
        return _calc_colorgrad(x, *line1_endpoints, color1, color2)
    def line2_colorgrad(x):
        return _calc_colorgrad(x, *line2_endpoints, color1, color2)

    # Direction vectors of each line
    direc1 = geom.STVector(line1_endpoints[1]) - geom.STVector(line1_endpoints[0])
    direc2 = geom.STVector(line2_endpoints[1]) - geom.STVector(line2_endpoints[0])
    grad = geom.Collection()
    # Form the monochromatic half ribbon at the tail end of the gradient
    # Overlap with the first polygon by half a division to mitigate any
    # boundary gaps
    start_point1, _ = line1_colorgrad(1/(2*divisions))
    start_point2, _ = line2_colorgrad(1/(2*divisions))
    grad.append(geom.HalfRibbon(
        geom.Ray(-direc1, start_point1),
        geom.Ray(-direc2, start_point2),
        # Explicitly turn off edge coloring
        draw_options={&#39;facecolor&#39;: color1, &#39;edgecolor&#39;: &#39;None&#39;, **draw_options}))
    # Interior polygons comprising the color gradient
    for i in range(divisions):
        start_point1, _ = line1_colorgrad(i/divisions)
        # Overlap bands by half a division
        end_point1, _ = line1_colorgrad((i+1+1/2)/divisions)
        start_point2, _ = line2_colorgrad(i/divisions)
        end_point2, _ = line2_colorgrad((i+1+1/2)/divisions)
        _, grad_color = line1_colorgrad((i+1/2)/divisions)
        grad.append(geom.polygon(
            [start_point1, end_point1, end_point2, start_point2],
            draw_options={&#39;facecolor&#39;: grad_color, **draw_options}))
    # Monochromatic half ribon at the head end of the gradient
    grad.append(geom.HalfRibbon(
        geom.Ray(direc1, line1_endpoints[1]),
        geom.Ray(direc2, line2_endpoints[1]),
        draw_options={&#39;facecolor&#39;: color2, &#39;edgecolor&#39;: &#39;None&#39;, **draw_options}))
    return grad</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="specrel.spacetime" href="index.html">specrel.spacetime</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="specrel.spacetime.gradient.gradient_line" href="#specrel.spacetime.gradient.gradient_line">gradient_line</a></code></li>
<li><code><a title="specrel.spacetime.gradient.lateral_gradient_ribbon" href="#specrel.spacetime.gradient.lateral_gradient_ribbon">lateral_gradient_ribbon</a></code></li>
<li><code><a title="specrel.spacetime.gradient.longitudinal_gradient_ribbon" href="#specrel.spacetime.gradient.longitudinal_gradient_ribbon">longitudinal_gradient_ribbon</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>